#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <time.h>
#define L 3
#define C 3
#define T 20

typedef struct{
	char nome[20];
	int tam;
}tApp;

typedef struct{
	char nome[20];
}display;

typedef struct{
	tApp info;
	int prox;
	int ant;
}No;

typedef struct{
	tApp info[T];
	int IL,IA,FL,FA;
}LLV;

typedef struct{
	int disp;
	int IL;
	No v[T];
}LLSE;

typedef struct{
	int disp;
	int IL;
	No v[T];
}LLDE;

typedef struct{
	int ind;
	int ind_LL;
}id;

/*
1 - Colocar instalando nos aplicativos que ficam dentro da fila, ai quando lotar a fila colocar o primeiro
que entrou como instalado;
2 - Fazer PILHA nos Instalados, procurando um meio de abrir 3 abas num aplicativo;
3 - Quando tudo tiver pronto reavalizar as variaveis utilizadas procurando pra elas ter o melhor entendimento
e COMENTAR trechos do codigo;
4 - APARENTEMENTE todas as funções de INSERIR E REMOVER LLDE E LLSE, FILA E PILHA foram ajeitadas, esperando compilação;
*/

void inicializarLLV(LLV *v){
	v->IL = -1;
	v->FL = -1; 
	v->IA = 0;
	v->FA = T;
}

void inicializarLLSE(LLSE *lis){
	int i;
	
	for(i=1;i<T;i++){
		lis->v[i].prox = i+1;
	}
	lis->disp = 1;
	lis->v[T].prox = 0;	
}

void inicializarLLDE(LLDE *lis){
	int i;
	
	for(i=1;i<=T;i++){
		lis->v[i].prox = i+1;
		lis->v[i].ant = i-1;
	}
	lis->disp = 1;
	lis->IL = -1;
	lis->v[1].ant = -1;
	lis->v[T].prox = 0;
}

void carregar_Arquivos(tApp *p){
	FILE *leitura;
	int i=0;
	
	leitura = fopen("MobileED.txt", "r");
	
	if(leitura == NULL){
		printf("Erro ao abrir o arquivo.\n");
		exit(0);
	}
	else{
		while((fscanf(leitura,"%s %d\n", &p[i].nome,&p[i].tam))!= EOF){
			i++;
		}
	}
	
	fclose(leitura);
}


void consultarStore(LLSE *lis, id *v){
	int i,j;
	
	i = lis->IL;
	for(j=0;j<T;j++){
		v[j].ind = j+1; 
	}
	j = 0;
	if(lis->v[i].prox == -1){
		v[j].ind_LL = i;
		printf("%d. %s - Tamanho: %d mb\n", v[j].ind, lis->v[i].info.nome,lis->v[i].info.tam);
	}
	else{
		j = 0;
		while(lis->v[i].prox != -1){
			v[j].ind_LL = i;
			printf("%d. %s - Tamanho: %d mb\n", v[j].ind, lis->v[i].info.nome,lis->v[i].info.tam);
			j++;
			i = lis->v[i].prox;
			if(lis->v[i].prox == -1){
				v[j].ind_LL = i;
				printf("%d. %s - Tamanho: %d mb\n", v[j].ind, lis->v[i].info.nome,lis->v[i].info.tam);
			}
		}
	}
}

void consultarApps(LLDE *lis){
	int i,j;
	id v[T];
	
	i = lis->IL;
	for(j=0;j<T;j++){
		v[j].ind = j+1; 
	}
	j = 0;
	if(lis->v[i].prox == -1){
		v[j].ind_LL = i;
		printf("%d. %s - Tamanho: %d mb\n", v[j].ind, lis->v[i].info.nome,lis->v[i].info.tam);
	}
	else{
		j = 0;
		while(lis->v[i].prox != -1){
			v[j].ind_LL = i;
			printf("%d. %s - Tamanho: %d mb\n", v[j].ind, lis->v[i].info.nome,lis->v[i].info.tam);
			j++;
			i = lis->v[i].prox;
			if(lis->v[i].prox == -1){
				v[j].ind_LL = i;
				printf("%d. %s - Tamanho: %d mb\n", v[j].ind, lis->v[i].info.nome,lis->v[i].info.tam);
			}
		}
	}
}

void consultarRum(LLV *v, int *indic, int *elemen_pilha){
	int i=0;
	
	if((v->info[i].tam > 0) && (v->info[i+1].tam > 0))
		printf("Apps em Execução:\n\n");
	else
		printf("App em Execução:\n\n");
	
	for(i=0;i<T;i++){
		if(v->info[i].tam != 0){
			if(v->info[i].tam == 34){
				if(*elemen_pilha != 1){
					printf("%d. %s || ABAS Abertas: %d - Consumo de Memória: %d mb\n", i+1, v->info[i].nome, *elemen_pilha,((v->info[i].tam/2)*(*elemen_pilha)));
				}
				else{
					printf("%d. %s - Consumo de Memória: %d mb\n", i+1, v->info[i].nome, (v->info[i].tam/2));
				}				
			}
			else{
				printf("%d. %s - Consumo de Memória: %d mb\n", i+1, v->info[i].nome, (v->info[i].tam/2));
				*indic = i+1;
			}
		}
	}
}


void inserirLLV(LLV *v, LLDE *old, int indic_orig, int *quant_elem){
	int i,j,k,local,controle=0,ind;
	
	if((old->v[indic_orig].info.tam <= v->info[0].tam)||(v->IL != v->IA)){
		local = 1;
	}
	else{
		for(i=0;i<T;i++){
			if(v->info[i].tam > old->v[indic_orig].info.tam){
				local = 2;
				break;
			}
			local = 3;
		}
	}
	switch(local){
		case 1:
			if(!(v->IL == v->IA && v->FL == v->FA)){
				if(v->FL == -1){
					v->IL = v->IA;
					v->info[v->IL] = old->v[indic_orig].info;
					(*quant_elem)++;
				}
				else{
					if(v->IL > v->IA){
						v->IL--;
						v->info[v->IL] = old->v[indic_orig].info;
					}
					else{
						v->FL++;
						for(j=v->FL;j>=v->IL;j--){
							v->info[j+1] = v->info[j];
						}
						v->info[0] = old->v[indic_orig].info;
						controle = 1;
						(*quant_elem)++;
					}
				}
			}
			
			if(controle == 0){
				if(!(v->IL == v->IA && v->FL == v->FA)){
					if(v->FL != v->FA){
						v->FL++;
					}
					else{
						for(i=v->IL;i<=v->FL;i++){
							v->info[i-1] = v->info[i];
						}
						v->IL--;
					}
					v->info[v->FL] = old->v[indic_orig].info;
				}
			}	
			break;
		case 2:
			for(k=0;k<(*quant_elem);k++){
				if(v->info[k].tam > old->v[indic_orig].info.tam){
					if(!(v->IL == v->IA && v->FL == v->FA)){
						ind = k;
						if(v->FL != v->FA){
							for(j=v->FL;j>=ind;j--){
								v->info[j+1] = v->info[j];
							}
							v->FL++;
							v->info[ind] = old->v[indic_orig].info;
							(*quant_elem)++;
						}
						else{
							for(j=v->IL;j<=ind;j++){
								v->info[j-1] = v->info[j];
							}
							v->IL--;
							v->info[ind] = old->v[indic_orig].info;
							(*quant_elem)++;
						}
						return;	
					}
				}
			}
			break;
		case 3:
			if(!(v->IL == v->IA && v->FL == v->FA)){
				if(v->FL != v->FA){
					v->FL++;
				}
				else{
					for(i = v->IL; i<=v->FL;i++){
						v->info[i-1] = v->info[i];
					}
					v->IL--;
					v->info[v->FL] = old->v[indic_orig].info;
				}
				v->info[v->FL] = old->v[indic_orig].info;
				(*quant_elem)++;
				break;
			}
		default:
			break;
	}	
}

void inserirLLSE(LLSE *lis, tApp *old, int indic_orig, int *quant_elem){
	int i,k,local,ind,novo,find;
	
	if((lis->v[lis->IL].info.tam > old[indic_orig].tam)||(lis->disp == 1)){
		local = 1;
	}
	else{
		i = lis->IL;
		if(lis->v[i].prox == -1){
			local = 2;
		}
		else{
			while(lis->v[i].prox != -1){
				if(lis->v[i].info.tam > old[indic_orig].tam){
					local = 3;
					break;
				}
				i = lis->v[i].prox;
				local = 2;
				if(lis->v[i].info.tam > old[indic_orig].tam){
					local = 3;
					break;
				}
				local = 2;
			}
		}
	}
	
	switch(local){
		case 1:
			if(!(lis->disp == -1)){
				ind = lis->disp;
				lis->v[ind].info = old[indic_orig];
				lis->disp = lis->v[ind].prox;
				if(*quant_elem != 0){
					lis->v[ind].prox = lis->IL;
					(*quant_elem)++;	
				}				
				else{
					lis->v[ind].prox = -1;
					(*quant_elem)++;
				}
				lis->IL = ind;
			}
			break;
		case 2:
			if(!(lis->disp == -1)){
				ind = lis->IL;
				while(lis->v[ind].prox != -1){
					ind = lis->v[ind].prox;
				}
				novo = lis->disp;
				lis->disp = lis->v[novo].prox;
				lis->v[novo].prox = lis->v[ind].prox;
				lis->v[ind].prox = novo;
				lis->v[novo].info = old[indic_orig];
				(*quant_elem)++;	
			}
			break;
		case 3:
            k = lis->IL;
			while(lis->v[k].prox != -1){
				if(lis->v[k].info.tam > old[indic_orig].tam){
					break;
				}
				k = lis->v[k].prox;
			}
			if(!(lis->disp == -1)){
				novo = lis->disp;
				lis->disp = lis->v[novo].prox;
				lis->v[novo].prox = k;
				find = lis->IL;
				while(lis->v[find].prox != k){
					find = lis->v[find].prox;
				}
				lis->v[find].prox = novo;
				lis->v[novo].info = old[indic_orig];
				(*quant_elem)++; 
			}
			break;
		default:
			break;
	}	
}

void inserirLLDE(LLDE *lis, tApp *old, int indic_orig, int *quant_elem, int *ind_tam){
	int local,ind,i,fim,meio,aux;
	
	if((lis->v[lis->IL].info.tam > old[indic_orig].tam)||(lis->disp == 1)){
		local = 1;
	}
	else{
		i = lis->IL;
		if(lis->v[i].prox == -1){
			local = 2;
		}
		else{
			while(lis->v[i].prox != -1){
				if(lis->v[i].info.tam > old[indic_orig].tam){
					local = 3;
					break;
				}
				i = lis->v[i].prox;
				local = 2;
				if(lis->v[i].info.tam > old[indic_orig].tam){
					local = 3;
					break;
				}
				local = 2;
			}
		}
	}	
	
	switch(local){
		case 1:
			if(!(lis->disp == -1)){
				if(lis->v[1].info.tam == 0){
					ind = lis->disp;
					lis->disp = lis->v[ind].prox;
					lis->v[ind].info = old[indic_orig];
					lis->v[ind].prox = lis->IL;
					lis->IL = ind;
					(*quant_elem)++;
					*ind_tam = ind;
				}
				else{
					ind = lis->disp;
					lis->disp = lis->v[ind].prox;
					lis->v[ind].info = old[indic_orig];
					lis->v[ind].prox = lis->IL;
					lis->v[ind].ant = lis->v[lis->IL].ant;
					lis->v[lis->IL].ant = ind;
					lis->IL = ind;
					(*quant_elem)++;
					*ind_tam = ind;
				}
			}
			break;
		case 2:
			if(!(lis->disp == -1)){
				fim = lis->IL;
				while(lis->v[fim].prox != -1){
					fim = lis->v[fim].prox;
				}
				ind = lis->disp;
				lis->disp = lis->v[ind].prox;
				lis->v[ind].ant = fim;
				lis->v[ind].prox = lis->v[fim].prox;
				lis->v[fim].prox = ind;
				lis->v[ind].info = old[indic_orig];
				(*quant_elem)++;
				*ind_tam = ind;
			}
			break;
		case 3:
			if(!(lis->disp == -1)){
				aux = lis->IL;
				while(lis->v[aux].prox != -1){
					if(lis->v[aux].info.tam > old[indic_orig].tam){
						break;
					}
					aux = lis->v[aux].prox;
				}
				meio = lis->IL;
				while(lis->v[meio].prox != aux){
					meio = lis->v[meio].prox;
				}
				ind = lis->disp;
				lis->disp = lis->v[ind].prox;
				lis->v[ind].prox = lis->v[meio].prox;
				lis->v[ind].ant = meio;
				lis->v[meio].prox = ind;
				lis->v[lis->v[meio].prox].ant = ind;
				lis->v[ind].info = old[indic_orig];
				(*quant_elem)++;
				*ind_tam = ind;
			}
			break;
		default:
			break;
	}
}

void inserirFILA(LLDE *lis, LLSE *old, int indic_orig, int *elem_fila){
	int ind;
	
	if(!(lis->disp == -1)){
		if(lis->v[1].info.tam == 0){
			ind = lis->disp;
			lis->disp = lis->v[ind].prox;
			lis->v[ind].info = old->v[indic_orig].info;
			lis->v[ind].prox = lis->IL;
			lis->IL = ind;
			(*elem_fila)++;
		}
		else{
			ind = lis->disp;
			lis->disp = lis->v[ind].prox;
			lis->v[ind].info = old->v[indic_orig].info;
			lis->v[ind].prox = lis->IL;
			lis->v[ind].ant = lis->v[lis->IL].ant;
			lis->v[lis->IL].ant = ind;
			lis->IL = ind;
			(*elem_fila)++;				
		}
	}
}

void inserirPILHA(LLSE *lis, LLDE *old, int indic_orig, int *quant_elem){
	int ind;
	
	if(!(lis->disp == -1)){
		ind = lis->disp;
		lis->v[ind].info = old->v[indic_orig].info;
		lis->disp = lis->v[ind].prox;
		if(*quant_elem != 0){
			lis->v[ind].prox = lis->IL;
			(*quant_elem)++;	
		}				
		else{
			lis->v[ind].prox = -1;
			(*quant_elem)++;
		}
		lis->IL = ind;
	}
}


void removerLLV(LLV *v, int remover, int *quant_elem){
	int i,j,local;
	
	if(remover == 0){
		local = 1;
	}
	else{
		if(remover == v->FL){
			local = 2; 
		}	   	
		else{
			local = 3;
		}
	}	
	
	switch(local){
		case 1:
			if(!(v->IL == -1)){
				v->info[v->IL].tam = 0;
				strcpy(v->info[v->IL].nome,"");
				v->IL++;
				(*quant_elem)--;
			}
			break;
		case 2:
			if(!(v->IL == -1)){
				v->info[v->FL].tam = 0;
				strcpy(v->info[v->FL].nome,"");
				v->FL--;
				(*quant_elem)--;
			}
			break;
		case 3:
			for(i=0;i<v->FL;i++){
				if(v->info[i].tam == v->info[remover].tam){
					if(!(v->IL == -1)){
						for(j=i;j<v->FL;j++){
							v->info[j] = v->info[j+1];
						}
						v->info[v->FL].tam = 0;
						strcpy(v->info[v->FL].nome,"");
			   			v->FL--;
			   			(*quant_elem)--;
						return;
					}
				}
			}	
			break;
		default:
		   	break;
	}
}

void removerLLSE(LLSE *lis, int remover, int *quant_elem){
	int i,j,ind,local,ind_ant,ind_rem;
	
	if(remover == lis->IL){
		local = 1;
	}
	else{
		i = lis->IL;
		while(lis->v[i].prox != -1){
			i = lis->v[i].prox;
			if(lis->v[i].prox == -1){
				if(remover == i){
					local = 2;
				}
			}
			else{
				local = 3;
			}
		}
	}
	
	switch(local){
		case 1:
			if(!(lis->IL == -1)){
				ind = lis->IL;
				lis->IL = lis->v[ind].prox;
				lis->v[ind].prox = lis->disp;
				lis->disp = ind;
				(*quant_elem)--;
			}
			break;
		case 2:
			if(!(lis->IL == -1)){
				i = lis->IL;
				while(lis->v[i].prox != -1){
					i = lis->v[i].prox;
				}
				j = lis->IL;
				while(lis->v[j].prox != i){
					j = lis->v[j].prox;
				}
				ind = j;
				lis->v[lis->v[ind].prox].prox = lis->disp;
				lis->disp = lis->v[ind].prox;
				lis->v[ind].prox = -1;
				(*quant_elem)--;
			}
			break;
		case 3:
			if(!(lis->IL == -1)){
				i = lis->IL;
				while(lis->v[i].prox != remover){
					i = lis->v[i].prox;
				}
				ind_ant = i;
				ind_rem = lis->v[ind_ant].prox;
				lis->v[ind_ant].prox = lis->v[ind_rem].prox;
				lis->v[ind_rem].prox = lis->disp;
				lis->disp = ind_rem;
				(*quant_elem)--;
			}
			break;
		default:
			break;
	}
}

void removerLLDE(LLDE *lis, int remover, int *quant_elem){
	int i,ind,local,ind_ant,ind_prox,fim;
	
	if(remover == lis->IL){
		local = 1;
	}
	else{
		i = lis->IL;
		while(lis->v[i].prox != -1){
			i = lis->v[i].prox;
			if(lis->v[i].prox == -1){
				if(remover == i){
					local = 2;
				}
			}
			else{
				local = 3;
			}
		}
	}
	
	switch(local){
		case 1:
			if(!(lis->IL == -1)){
				ind = lis->IL;
				lis->IL = lis->v[ind].prox;
				lis->v[lis->IL].ant = lis->v[ind].ant;
				lis->v[ind].prox = lis->disp;	
				lis->disp = ind;
				(*quant_elem)--;
			}
			break;
		case 2:
			if(!(lis->IL == -1)){
				fim = lis->IL;
				while(lis->v[fim].prox != -1){
					fim = lis->v[fim].prox;
				}
				ind_ant = lis->v[fim].ant;
				lis->v[ind_ant].prox = lis->v[fim].prox;
				lis->v[fim].prox = lis->disp;
				lis->disp = fim;
				(*quant_elem)--;
			}
			break;
		case 3:
			if(!(lis->IL == -1)){
				ind_ant = lis->v[remover].ant;
				ind_prox = lis->v[remover].prox;
				lis->v[ind_ant].prox = ind_prox;
				lis->v[ind_prox].ant = ind_ant;
				lis->v[remover].prox = lis->disp;
				lis->disp = remover;
				(*quant_elem)--;
			}
			break;
		default:
			break;
	}
}

void removerFILA(LLDE *lis, tApp *realoc, int *indic){
	int fim,ind_ant;
	
	fim = lis->IL;
	while(lis->v[fim].prox != -1){
		fim = lis->v[fim].prox;
	}
	realoc[*indic] = lis->v[fim].info;
	ind_ant = lis->v[fim].ant;
	lis->v[ind_ant].prox = lis->v[fim].prox;
	lis->v[fim].prox = lis->disp;
	lis->disp = fim;
	(*indic)++;
}

void removerPILHA(LLSE *lis){
	int ind;
	
	if(!(lis->disp == 1)){
		ind = lis->IL;
		lis->IL = lis->v[ind].prox;
		lis->v[ind].prox = lis->disp;
		lis->disp = ind;
	}
}


void sleep(time_t delay){
	time_t timer0, timer1;
	
	time(&timer0);
	do{
		time(&timer1);
	}while((timer1-timer0)<delay);
}


void store(LLSE *s, LLDE *ins, int *cont_tam, int *quant_inst){
	system("cls");
	int resp,i,num,ind=0,var=0,total_elem=0,tam_total=150,elemen_fila=0,ind_tam=0,indic=0;
	LLDE fila;
	tApp realocador[T];
	id v[T];
	
	for(i=0;i<T;i++){
		fila.v[i].info.tam = 0;
		realocador[i].tam = 0;
		strcpy(fila.v[i].info.nome,"");
		strcpy(realocador[i].nome,"");	  		  
	}
	inicializarLLDE(&fila);
	
	printf("Apps Disponíveis:\n\n");
	consultarStore(s,&v[0]);
	printf("\n");
	while(resp != 100){
		printf("Digite o número do App que deseja instalar: ");
		scanf("%d", &num);
		printf("\n");
		//"FOR" PARA VERIFICIAR SE o numero digitado eh maior que o total de elementos e Se o aplicativo ja foi instalado.
		for(i=0;i<T;i++){
			if(v[i].ind == num){
				ind = v[i].ind_LL;
			}
		}
		for(i=0;i<T;i++){
			if(s->v[i].info.tam != 0){
				total_elem++;
			}
			if(s->v[ind].info.tam == ins->v[i].info.tam){
				var = 1;
			}
		}
		if(num > total_elem){
			break;
		}
		if(var == 1){
			printf("Aplicativo já Instalado.\n");
		}
	   	else{
     		if(elemen_fila < 3){
				inserirFILA(&fila,s,num,&elemen_fila); 
			}
			else{
				removerFILA(&fila,&realocador[0],&indic);
				for(i=0;i<T;i++){
					if(realocador[i].tam != 0)
						inserirLLDE(ins,&realocador[0],i,quant_inst,&ind_tam);
				}
			}
			i = fila.IL;
			if(fila.v[i].prox == -1)
				printf("%s Instalando...\n",fila.v[i].info.nome);  
			else{
				while(fila.v[i].prox != -1){
					printf("%s Instalando...\n",fila.v[i].info.nome);  
					i = fila.v[i].prox;
					if(fila.v[i].prox == -1)
						printf("%s Instalando...\n",fila.v[i].info.nome);
				}
			}		
			if(elemen_fila >= 3){
	   			*cont_tam += ins->v[ind_tam].info.tam;
				if(*cont_tam > tam_total){
					printf("Espaço Insuficiente.\n");
					*cont_tam -= ins->v[ind_tam].info.tam;
					return; 
				}
				printf("App %s Instalado com sucesso.\n",ins->v[ind_tam].info.nome);
				printf("Memória: Atual: %d mb | MAX: 150 mb\n", *cont_tam);
			}
		}
		printf("\n");
		
		printf("Deseja instalar outro App? <1-Continuar,0-Sair> ");
		scanf(" %d", &resp);
		if(resp > 1){
			printf("Opção Inválida\n\n");
			while(resp > 1){
				printf("Deseja instalar outro App? <1-Continuar,0-Sair> ");
				scanf(" %d", &resp);
				if(resp > 1)
					printf("Opção Inválida\n\n");
			}
		}
		system("cls");
		printf("Apps Disponíveis:\n\n");
		consultarStore(s,&v[0]);
		printf("\n");
	}
	system("cls");
}


void meusApps(LLDE *ins, LLV *rum, int *quant_inst, int *cont_tam,int *cont_rum, int *quant_rum, LLSE *pilha, int *elemen_pilha){
	system("cls");
	int num,i,j,var=0,remover,resp,resp2=2,tam_total = 100,aba=1;
	id v[T];
	
	for(i=0;i<T;i++){
		pilha->v[i].info.tam = 0;
		strcpy(pilha->v[i].info.nome,"");	  		  
	}
	inicializarLLSE(pilha);
	
	printf("---------------\n1 - Apps Instalados\n2 - Desinstalar App\n0 - Voltar\n---------------\n");
	scanf(" %d", &resp);
	while(resp != 0){
		switch(resp){
			case 0:
				return;
			case 1:
				system("cls");
				if(*cont_tam == 0){
					printf("Sem Apps Instalados\n");
					sleep(2);
					system("cls");
					break;
				}
				printf("Apps Instalados:\n\n");
				consultarApps(ins);
				printf("\n");
				while(resp2 != 0){
					printf("Digite o numero do App que deseja Executar: ");
					scanf(" %d", &num);
					if(num > *quant_inst){
						printf("Opção Inválida\n\n");
						while(num > *quant_inst){
							printf("Digite o numero do App que deseja Executar: ");
							scanf(" %d", &num);
							if(num > *quant_inst)
								printf("Opção Inválida\n\n");
						}
					}
					for(i=0;i<T;i++){
						if(v[i].ind == num){
							num = v[i].ind_LL;
						}
					}
					for(i=0;i<T;i++){
						if(ins->v[num].info.tam == rum->info[i].tam){
							var = 1;
							if(ins->v[num].info.tam == 34){
								var = 2;
							}
						}	
					}
					if(var > 0){
						if(var == 1){
							printf("Aplicativo já em Execução.\n");
							var = 0;
						}
						else{
							if(*elemen_pilha == 0){
								inserirPILHA(pilha,ins,num,elemen_pilha);
								inserirLLV(rum,ins,num,quant_rum);
								*cont_rum += (ins->v[num].info.tam/2);
								if(*cont_rum > tam_total){
									printf("Memória Insuficiente.\n");
									sleep(2);
									system("cls");
									return;
								}
								printf("App %s em Execução.\n", ins->v[num].info.nome);
								printf("Memória RAM: Atual: %d mb | MAX: 100 mb\n", *cont_rum);
							}
							else{
								inserirPILHA(pilha,ins,num,elemen_pilha);
								*cont_rum += (ins->v[num].info.tam/2);
								if(*cont_rum > tam_total){
									printf("Memória Insuficiente.\n");
									sleep(2);
									system("cls");
									return;
								}
								aba++;
								printf("%s - Nova aba %d\n", ins->v[num].info.nome,aba);
								printf("Memória RAM: Atual: %d mb | MAX: 100 mb\n", *cont_rum);								
							}
							var = 0;
						}
					}		
					else{
						*cont_rum += (ins->v[num].info.tam/2);
						if(*cont_rum > tam_total){
							printf("Memória Insuficiente.\n");
							sleep(2);
							system("cls");
							return;
						}
						printf("App %s em Execução.\n", ins->v[num].info.nome);
						printf("Memória RAM: Atual: %d mb | MAX: 100 mb\n", *cont_rum);
						inserirLLV(rum,ins,num,quant_rum);
					}
					printf("\n");
					printf("Continuar - 1, Sair - 0: ");
					scanf(" %d", &resp2);
					if(resp2 == 0){
						break;
					}
					system("cls");
					printf("Apps Instalados:\n\n");
					consultarApps(ins);
					printf("\n");
				}
				system("cls");
				break;
			case 2:
				printf("\n");
				system("cls");
				if(*cont_tam == 0){
					printf("Sem Apps Instalados\n");
					sleep(2);
					system("cls");
					break;
				}
				printf("Desinstalar:\n\n");
				i = ins->IL;
				for(j=0;j<T;j++){
					v[j].ind = j+1; 
				}
				j = 0;
				if(ins->v[i].prox == -1){
					v[j].ind_LL = i;
					printf("%d. %s - Ocupando: %d mb\n", v[j].ind, ins->v[i].info.nome,ins->v[i].info.tam);
				}
				else{
					j = 0;
					while(ins->v[i].prox != -1){
						v[j].ind_LL = i;
						printf("%d. %s - Ocupando: %d mb\n", v[j].ind, ins->v[i].info.nome,ins->v[i].info.tam);
						j++;
						i = ins->v[i].prox;
						if(ins->v[i].prox == -1){
							v[j].ind_LL = i;
							printf("%d. %s - Ocupando: %d mb\n", v[j].ind, ins->v[i].info.nome,ins->v[i].info.tam);
						}
					}
				}	
				printf("\n");
				printf("Memória: Atual: %d mb | MAX: 150 mb\n\n", *cont_tam);
				while(remover != 0){
					printf("Digite o número do App que deseja Desinstalar <0-Sair>: ");
					scanf(" %d", &remover);
					if(remover == 0){
						break;
					}
					if(remover > *quant_inst){
						printf("Opção Inválida\n");
						return;
					}
					for(i=0;i<T;i++){
						if(v[i].ind == remover){
							remover = v[i].ind_LL;
						}
					}
					for(i=0;i<T;i++){
						if(ins->v[remover].info.tam == rum->info[i].tam){
							printf("App em Execução.\n\n");
							printf("Digite o número do App que deseja Desinstalar <0-Sair>: ");
							scanf(" %d", &remover);
							if(remover == 0){
								break;
							}
						}
					}		
					*cont_tam -= ins->v[remover].info.tam;
					removerLLDE(ins,remover,quant_inst);
					printf("\n");
					printf("Memória: Atual: %d mb | MAX: 150 mb\n\n", *cont_tam);
					sleep(2);
					system("cls");
					printf("Desinstalar:\n\n");
					i = ins->IL;
					for(j=0;j<T;j++){
						v[j].ind = j+1; 
					}
					j = 0;
					if(ins->v[i].prox == -1){
						v[j].ind_LL = i;
						printf("%d. %s - Ocupando: %d mb\n", v[j].ind, ins->v[i].info.nome,ins->v[i].info.tam);
					}
					else{
						j = 0;
						while(ins->v[i].prox != -1){
							v[j].ind_LL = i;
							printf("%d. %s - Ocupando: %d mb\n", v[j].ind, ins->v[i].info.nome,ins->v[i].info.tam);
							j++;
							i = ins->v[i].prox;
							if(ins->v[i].prox == -1){
								v[j].ind_LL = i;
								printf("%d. %s - Ocupando: %d mb\n", v[j].ind, ins->v[i].info.nome,ins->v[i].info.tam);
							}
						}
					}
					printf("\n");
					printf("Memória: Atual: %d mb | MAX: 150 mb\n\n", *cont_tam);
				}
				system("cls");
				break;
			default:
				printf("Opção Inválida\n");
				break;
		}
	   	printf("---------------\n1 - Apps Instalados\n2 - Desinstalar App\n0 - Voltar\n---------------\n");
		scanf(" %d", &resp);
	}
	system("cls");
}

	
void executando(LLV *rum, int *cont_rum, int *quant_rum, LLSE *pilha, int *elemen_pilha){
	system("cls");
	int remover,indic;
			
	consultarRum(rum,&indic,elemen_pilha);
	while(remover != 0){
		printf("\n");
		printf("Memória RAM: Atual: %d mb | MAX: 50 mb.\n\n", *cont_rum);
		printf("Número do App a parar <0 - Sair>: ");
		scanf(" %d", &remover);
		if(remover == 0){
			system("cls");
			return;
		}
		if(remover > indic){
			printf("Opção Inválida\n");
			return;
		}
		if(rum->info[remover-1].tam == 34){
			removerPILHA(pilha);
			*cont_rum -= (rum->info[remover-1].tam/2);
			if(*elemen_pilha == 1){
				removerLLV(rum,remover-1,quant_rum);
			}
			(*elemen_pilha)--;	
		}
		else{
			*cont_rum -= (rum->info[remover-1].tam/2);
			removerLLV(rum,remover-1,quant_rum);
		}
		printf("\n");
        printf("Memória RAM: Atual: %d mb | MAX: 50 mb.\n\n", *cont_rum);
        sleep(2);
        system("cls");
        consultarRum(rum,&indic,elemen_pilha);
	}
	system("cls");
}


void menuprin(LLSE *s,LLDE *ins,LLV *rum, int *cont_tam, int *cont_rum){
	system("cls");
	int resp,quant_inst=0,quant_rum=0,elemen_pilha=0;
	int i,j,a,k=0;
	LLSE pilha;
	display m[L][C];

	for(j=0;j<L;j++){
		for(i=0;i<C;i++){
			strcpy(m[j][i].nome,ins->v[k].info.nome);				
			k++; 
		}
	}
	for(j=0;j<L;j++){
		for(i=0;i<C;i++){
			if(i != C-1){
				a = strcmp(m[j][i].nome,"");
				if(a==0){
					printf("[%s     ] ____ ");
				}
				else{
					printf("[%s] ____ ", m[j][i].nome);
				}
			}
			else{
				a = strcmp(m[j][i].nome,"");
				if(a==0){
					printf("[     ]");
				}
				else{
					printf("[%s]", m[j][C-1].nome);
				}
			}			
		}
		printf("\n\n");
	}
	printf("==========================================\n");
	printf("[1.StoreED]  [2.MeusAppsED]  [3.AppRumED]\n");
	printf("==========================================\n");
	scanf(" %d", &resp);
	
	while(resp != 0){
		switch(resp){
			case 1:
				store(s,ins,cont_tam,&quant_inst);
				break;
			case 2:
				meusApps(ins,rum,&quant_inst,cont_tam,cont_rum,&quant_rum,&pilha,&elemen_pilha);
				break;
			case 3:
				executando(rum,cont_rum,&quant_rum,&pilha,&elemen_pilha);
				break;
			default:
				printf("Opção inválida!\n");
				sleep(1);
        		system("cls");
				break;
		};
		
		k=0;
		for(j=0;j<L;j++){
			for(i=0;i<C;i++){
				strcpy(m[j][i].nome,"");
			}
		}	   	
		for(j=0;j<L;j++){
			for(i=0;i<C;i++){
				if(k <= quant_inst){
					strcpy(m[j][i].nome,ins->v[k].info.nome);				
					k++;
				}
				else{
					strcpy(m[j][i].nome,"");
					break;
				}
			}
		}
		for(j=0;j<L;j++){
			for(i=0;i<C;i++){
				if(i != C-1){
					a = strcmp(m[j][i].nome,m[j-1][i-1].nome);
					if(a==0){
						strcpy(m[j][i].nome,"");
						printf("[%s] ____ ", m[j][i].nome);
					}
					else{
						printf("[%s] ____ ", m[j][i].nome);
					}
				}
				else{
					a = strcmp(m[j][i].nome,m[j-1][i-1].nome);
					if(a==0){
						strcpy(m[j][i].nome,"");
						printf("[%s]", m[j][i].nome);
					}
					else{
						printf("[%s]", m[j][i].nome);
					}
				}			
			}
			printf("\n\n");
		}
		
		printf("==========================================\n");
		printf("[1.StoreED]  [2.MeusAppsED]  [3.AppRumED]\n");
		printf("==========================================\n");
		scanf(" %d", &resp);
	}
}

int main(){
	setlocale(LC_ALL,"Portuguese");
	
	int i,cont_tam=0,cont_rum=0,quant_store;
	tApp aux[T];
	LLSE apps_store;
	LLDE apps_instalados;
	LLV apps_executando;
	
	for(i=0;i<T;i++){
		apps_store.v[i].info.tam = 0;
		apps_instalados.v[i].info.tam = 0;
		apps_executando.info[i].tam = 0;
		aux[i].tam = 0;
		strcpy(apps_store.v[i].info.nome,"");
		strcpy(apps_instalados.v[i].info.nome,"");
		strcpy(apps_executando.info[i].nome,"");
		strcpy(aux[i].nome,"");  
	}
	
	inicializarLLSE(&apps_store);
	inicializarLLDE(&apps_instalados);
	inicializarLLV(&apps_executando);
	
	carregar_Arquivos(&aux[0]);
	for(i=0;i<T;i++){
		if(aux[i].tam != 0){
			inserirLLSE(&apps_store,&aux[0],i,&quant_store);
		}
	}
	
	menuprin(&apps_store,&apps_instalados,&apps_executando,&cont_tam,&cont_rum);
	
	return 0;
}
