#include <stdio.h>
#include <stdlib.h>

typedef struct arv{
	int valor,altura;
	struct arv* esq;
	struct arv* dir;
	struct arv* pai;
}Avl;

typedef struct{
	int num;
	char cha;
}tApp;

Avl* Cria(){
	return NULL;
}

int altura(Avl* a){
	return a == NULL? 0 : a->altura; 
}

int max(int a, int b){
	return (a > b)? a : b;
}

Avl* rotacao_Esquerda(Avl* a){
	Avl* aux = a->dir;
	
	//ROTAÇÃO
	a->dir = aux->esq;
	aux->esq = a;
	
	//ALTURA
	a->altura = max(altura(a->esq),altura(a->dir)) + 1;
	aux->altura = max(altura(aux->esq),altura(aux->dir)) + 1;
	
	return aux;
}

Avl* rotacao_Direita(Avl* a){
	Avl* aux = a->esq;
	
	//ROTAÇÃO
	a->esq = aux->dir;
	aux->dir = a;
	
	//ALTURA
	a->altura = max(altura(a->esq),altura(a->dir)) + 1;
	aux->altura = max(altura(aux->esq),altura(aux->dir)) + 1;
	
	return aux;
}

int fatorBalanceamento(Avl* a){
	if(a == NULL)
		return 0;
	return altura(a->dir) - altura(a->esq);
}
/*
Avl* deleteKey(int x, Avl* y){
	if(y == null)
		return;
	
	Avl* n = y;
	Avl* pai = y;
	Avl* delNo = NULL;
	Avl* filho = y;
	
	while(filho != NULL){
		pai = n;
		n = filho;
		filho = x >= n->valor ? n->dir : n->esq;
		if(x == n->valor)
			delNo = n;
	}
	
	if(delNo != NULL){
		delNo->valor = n->valor;
		
		filho = n->esq != NULL ? n->esq : n->dir;
		
		if(y->valor == x)
			y = filho;
		else{
			if(pai->esq == n)
				pai->esq = filho;
			else
				pai->dir = filho;
			rebalanceia(pai);
		}
	}
}
*/

Avl* identificaPai(Avl* a, int v){
	Avl* pai = NULL;
	
	if(a == NULL)
		return NULL;
	else{
		while(a->valor != v){ 
			pai = a;
			if(a->valor > v)
				a = a->esq;
    		else
    			a = a->dir;
		}	
    	return pai;
	}	
}

Avl* inserir(Avl* a, int v){
	int fb;
	
	if(a == NULL){
    	a = (Avl*)malloc(sizeof(Avl)); 
    	a->valor = v;
		a->esq = a->dir = a->pai = NULL;
    	a->altura = 1;
	}
    else if(v < a->valor)
    	a->esq = inserir(a->esq,v);	
    else if(v > a->valor)
    	a->dir = inserir(a->dir,v); 	
    else
    	;
    
    a->pai = identificaPai(a,v);
	a->altura = max(altura(a->esq),altura(a->dir)) + 1;
	
	fb = fatorBalanceamento(a);
	
	if(fb < -1 && v < a->esq->valor)
		return rotacao_Direita(a);  // ROTAÇÃO PARA DIREITA
	else if(fb > 1 && v > a->dir->valor)
		return rotacao_Esquerda(a); // Rotação para Esquerda
	else if(fb < -1 && v > a->esq->valor){ // DUPLA RE
		a->esq = rotacao_Esquerda(a->esq);
		return rotacao_Direita(a);
	}
	else if(fb > 1 && v < a->dir->valor){ // DUPLA RD
		a->dir = rotacao_Direita(a->dir);
		return rotacao_Esquerda(a);
	}
	
	return a;	
}

Avl* findMin(Avl* y){
    if(y->esq == NULL)
        return y;
    else
        return findMin(y->esq);
}
 
void findMax(Avl* y){
    if(y->dir == NULL)
        printf("Maior valor presente na AVL: %d\n", y->valor);
    else
        findMax(y->dir);
}

Avl* excluiElemento(int x, Avl* y){
	if(y == NULL)
		return y;
	else{
		if(x < y->valor)
			y->esq = excluiElemento(x,y->esq);
		else if(x > y->valor)
			y->dir = excluiElemento(x,y->dir);
		else{
			/*
			if((y->esq == NULL) || (y->dir == NULL)){ // NO COM 1 FILHO OU SEM FILHO
				Avl* aux = y->esq ? y->esq : y->dir;
				if(aux == NULL){ // CASO: SEM FILHO
					aux = y;
					y = NULL;
				}
				else // CASO: 1 FILHO
					*y = *aux;	// Copy the contents of the non-empty child
				free(aux);
			}
			else{
	            // node with two children: Get the inorder
                // successor (smallest in the right subtree)
				Avl* aux = findMin(y->dir);
				
				y->valor = aux->valor; // Copy the inorder successor's data to this node
				
				y->dir = excluiElemento(aux->valor,y->dir); // Delete the inorder successor				
			}
			*/
			if(y->esq == NULL)
				y = y->dir;
			else if(y->dir == NULL)
				y = y->esq;
			else{
				Avl* aux = findMin(y->dir);
				int sucessor = aux->valor;
				y->valor = sucessor;
				y->dir = excluiElemento(sucessor,y->dir); 
			} 
		}
		// If the tree had only one node then return
    	if (y == NULL)
    		return y;
    	
    	y->altura = max(altura(y->esq),altura(y->dir)) + 1;
    	
    	int	fb = fatorBalanceamento(y);
    	
    	
    	if(fb > 1 && fatorBalanceamento(y->esq) >= 0) // ROT. ESQUERDA
    		return rotacao_Direita(y);
    	else if(fb > 1 && fatorBalanceamento(y->esq) < 0){ // DUPLA R.ESQUERDA
    		y->esq = rotacao_Esquerda(y->esq);
			return rotacao_Direita(y);	
		}
		else if(fb < -1 && fatorBalanceamento(y->dir) <= 0) // ROT. DIREITA
			return rotacao_Esquerda(y);
		else if(fb < -1 && fatorBalanceamento(y->dir) > 0){ // DUPLA R. DIREITA
			y->dir = rotacao_Direita(y->dir);
			return rotacao_Esquerda(y);
		}
			
		return y;		
	}
}

/*
130	    private AVLTreeNode delete(AVLTreeNode node, int key)
131	    {
132	         
133	        if (node == null) return null;
134	        
135	        if (key < node.data)
136	        {
137	            node.left = delete(node.left, key);
138	        }
139	        else if (key > node.data)
140	        {
141	            node.right = delete(node.right, key);
142	        }
143	        
144	        else  
145	        {
146	             
147	            if (node.left == null)
148	            {
149	                node = node.right;
150	            }
151	            else if (node.right == null)
152	            {
153	                node = node.left;
154	            }
155	            
156	             
157	             
158	             
159	            else
160	            {
161	                int inorderSuccessorValue = getMinValue(node.right);
162	                node.data = inorderSuccessorValue;
163	                node.right = delete(node.right, inorderSuccessorValue);
164	            }
165	        }
166	
167	         
168	        if (node == null)
169	        {
170	            return null;
171	        }
172	        
173	         
174	        updateHeight(node);
175	        
176	         
177	        int balance = getBalance(node);
178	        
179	        if (balance > 1)  
180	        {
181	            if (getBalance(node.left) >= 0)  
182	            {
183	                node = rotateRight(node);
184	            }
185	            else  
186	            {
187	                node.left = rotateLeft(node.left);
188	                node = rotateRight(node);
189	            }
190	        }
191	        
192	        else if (balance < -1)  
193	        {
194	            if (getBalance(node.right) <= 0)  
195	            {
196	                node = rotateLeft(node);
197	            }
198	            else  
199	            {
200	                node.right = rotateRight(node.right);
201	                node = rotateLeft(node);
202	            }
203	        }
204	        return node;
205	    }
*/

void imprime(Avl* a){
	if(a != NULL){
    	imprime(a->esq);
    	printf("%d(FB: %d) ", a->valor,fatorBalanceamento(a));
    	imprime(a->dir);
	}
}

Avl* abb_busca(Avl* r, int v){
	if(r == NULL)
		return NULL;
  	else if(r->valor > v)
    	return abb_busca(r->esq,v);
    else if(r->valor < v)
    	return abb_busca(r->dir,v);
    else
    	return r;
}

void carregar_Arquivos(tApp *p){
	FILE *leitura;
	int i=0;
	
	leitura = fopen("Enem.txt", "r");
	
	if(leitura == NULL){
		printf("Erro ao abrir o arquivo.\n");
		exit(0);
	}
	else{
		while((fscanf(leitura,"%d%c", &p[i].num,&p[i].cha))!= EOF){
			i++;
		}
	}
	
	fclose(leitura);
}

int main(){
	Avl* a;
	//Avl* pai;
	int resp,i=1;
	//tApp aux[10];
	
	a = Cria();
	/*
	carregar_Arquivos(&aux[0]);
	for(i=0;i<9;i++){
		a = inserir(a,aux[i].num);
		printf("Inserindo: %d\n", aux[i].num);
		printf("%d: ", i+1);
		imprime(a);
		printf("\n\n");
	}
	x = 1;
	while(x != 0){
		printf("Digite o No: ");
		scanf("%d", &x);
		pai = identificaPai(a,x);
		printf("Pai do No %d: %d\n", x,pai->valor);
	}	
	*/
	
	printf("Numero: ");
	scanf("%d", &resp);
	while(resp != 0){
		a = inserir(a,resp);
		printf("Inserindo: %d || AVL : %d elementos\n", resp,i);
		printf("%d: ", i+1);
		i++;
		imprime(a);
		printf("\n\nNum: ");
		scanf("%d", &resp);
	}
	
	printf("Deleta NO: ");
	scanf("%d", &resp);
	while(resp != 0){
		a = excluiElemento(resp,a);
		printf("Excluindo: %d\n", resp);
		//printf("%d: ", i+1);
		i++;
		imprime(a);
		printf("\n\nNum: ");
		scanf("%d", &resp);
	}
		
	return 0;
}
