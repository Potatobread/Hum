#include <stdio.h>
#include <stdlib.h>

typedef struct arv{
	int valor,altura;
	struct arv* esq;
	struct arv* dir;
	struct arv* pai;
}Avl;

typedef struct{
	int num;
	char cha;
}tApp;

Avl* Cria(){
	return NULL;
}

int altura(Avl* a){
	return a == NULL? 0 : a->altura; 
}

int max(int a, int b){
	return (a > b)? a : b;
}

Avl* rotacao_Esquerda(Avl* a){
	Avl* aux = a->dir;
	
	//ROTAÇÃO
	a->dir = aux->esq;
	aux->esq = a;
	
	//ALTURA
	a->altura = max(altura(a->esq),altura(a->dir)) + 1;
	aux->altura = max(altura(aux->esq),altura(aux->dir)) + 1;
	
	return aux;
}

Avl* rotacao_Direita(Avl* a){
	Avl* aux = a->esq;
	
	//ROTAÇÃO
	a->esq = aux->dir;
	aux->dir = a;
	
	//ALTURA
	a->altura = max(altura(a->esq),altura(a->dir)) + 1;
	aux->altura = max(altura(aux->esq),altura(aux->dir)) + 1;
	
	return aux;
}

int fatorBalanceamento(Avl* a){
	if(a == NULL)
		return 0;
	return altura(a->dir) - altura(a->esq);
}

Avl* identificaPai(Avl* a, int v){
	Avl* pai = NULL;
	
	if(a == NULL)
		return NULL;
	else{
		while(a->valor != v){ 
			pai = a;
			if(a->valor > v)
				a = a->esq;
    		else
    			a = a->dir;
		}	
    	return pai;
	}	
}

Avl* inserir(Avl* a, int v){
	int fb;
	
	if(a == NULL){
    	a = (Avl*)malloc(sizeof(Avl)); 
    	a->valor = v;
		a->esq = a->dir = a->pai = NULL;
    	a->altura = 1;
	}
    else if(v < a->valor)
    	a->esq = inserir(a->esq,v);	
    else if(v > a->valor)
    	a->dir = inserir(a->dir,v); 	
    else
    	;
    
    a->pai = identificaPai(a,v);
	a->altura = max(altura(a->esq),altura(a->dir)) + 1;
	
	fb = fatorBalanceamento(a);
	
	if(fb < -1 && v < a->esq->valor)
		return rotacao_Direita(a);  // ROTAÇÃO PARA DIREITA
	else if(fb > 1 && v > a->dir->valor)
		return rotacao_Esquerda(a); // Rotação para Esquerda
	else if(fb < -1 && v > a->esq->valor){ // DUPLA RE
		a->esq = rotacao_Esquerda(a->esq);
		return rotacao_Direita(a);
	}
	else if(fb > 1 && v < a->dir->valor){ // DUPLA RD
		a->dir = rotacao_Direita(a->dir);
		return rotacao_Esquerda(a);
	}
	
	return a;	
}

Avl* findMin(Avl* y){
    if(y->esq == NULL)
        return y;
    else
        return findMin(y->esq);
}
 
void findMax(Avl* y){
    if(y->dir == NULL)
        printf("Maior valor presente na AVL: %d\n", y->valor);
    else
        findMax(y->dir);
}

Avl* excluiElemento(int x, Avl* y){
	if(y == NULL)
		return y;
	else{
		if(x < y->valor)
			y->esq = excluiElemento(x,y->esq);
		else if(x > y->valor)
			y->dir = excluiElemento(x,y->dir);
		else{
			/*
			if((y->esq == NULL) || (y->dir == NULL)){ // NO COM 1 FILHO OU SEM FILHO
				Avl* aux = y->esq ? y->esq : y->dir;
				if(aux == NULL){ // CASO: SEM FILHO
					aux = y;
					y = NULL;
				}
				else // CASO: 1 FILHO
					*y = *aux;	// Copy the contents of the non-empty child
				free(aux);
			}
			else{
	            // node with two children: Get the inorder
                // successor (smallest in the right subtree)
				Avl* aux = findMin(y->dir);
				
				y->valor = aux->valor; // Copy the inorder successor's data to this node
				
				y->dir = excluiElemento(aux->valor,y->dir); // Delete the inorder successor				
			}
			*/
			if(y->esq == NULL && y->dir == NULL){ // NO NAO TEM FILHOS
				free(y);
				y = NULL;
			}
			else if(y->esq == NULL || y->dir == NULL){
				if(y->esq == NULL){
					Avl* aux = y;
					y = y->dir;
					free(aux);
				}
				if(y->dir == NULL){
					Avl* aux = y;
					y = y->esq;
					free(aux);
				}
			}
			else{
				Avl* aux = y->esq;
				while(aux->dir != NULL)
					aux = aux->dir;
					
				y->valor = aux->valor;
				aux->valor = x;
				y->esq = excluiElemento(x,y->esq);
			}
		}
		// If the tree had only one node then return
    	if (y == NULL)
    		return y;
    	
    	y->altura = max(altura(y->esq),altura(y->dir)) + 1;
    	
    	int	fb = fatorBalanceamento(y);
    	
    	if(fb > 1 && fatorBalanceamento(y->esq) >= 0) // ROT. ESQUERDA
    		return rotacao_Direita(y);
    	else if(fb > 1 && fatorBalanceamento(y->esq) < 0){ // DUPLA R.ESQUERDA
    		y->esq = rotacao_Esquerda(y->esq);
			return rotacao_Direita(y);	
		}
		else if(fb < -1 && fatorBalanceamento(y->dir) <= 0) // ROT. DIREITA
			return rotacao_Esquerda(y);
		else if(fb < -1 && fatorBalanceamento(y->dir) > 0){ // DUPLA R. DIREITA
			y->dir = rotacao_Direita(y->dir);
			return rotacao_Esquerda(y);
		}
			
		return y;		
	}
}


void imprime(Avl* a){
	if(a != NULL){
    	imprime(a->esq);
    	printf("%d(FB: %d) ", a->valor,fatorBalanceamento(a));
    	imprime(a->dir);
	}
}

void imprimePre(Avl* a){
	if(a != NULL){
		printf("%d(FB: %d) ", a->valor,fatorBalanceamento(a));
    	imprime(a->esq);
    	imprime(a->dir);
	}
}

void carregar_Arquivos(tApp *p){
	FILE *leitura;
	int i=0;
	
	leitura = fopen("Enem.txt", "r");
	
	if(leitura == NULL){
		printf("Erro ao abrir o arquivo.\n");
		exit(0);
	}
	else{
		while((fscanf(leitura,"%d%c", &p[i].num,&p[i].cha))!= EOF){
			i++;
		}
	}
	
	fclose(leitura);
}

int main(){
	Avl* a;
	//Avl* pai;
	int resp,i=1;
	//tApp aux[10];
	
	a = Cria();
	/*
	carregar_Arquivos(&aux[0]);
	for(i=0;i<9;i++){
		a = inserir(a,aux[i].num);
		printf("Inserindo: %d\n", aux[i].num);
		printf("%d: ", i+1);
		imprime(a);
		printf("\n\n");
	}
	x = 1;
	while(x != 0){
		printf("Digite o No: ");
		scanf("%d", &x);
		pai = identificaPai(a,x);
		printf("Pai do No %d: %d\n", x,pai->valor);
	}	
	*/
	
	printf("Numero: ");
	scanf("%d", &resp);
	while(resp != 0){
		a = inserir(a,resp);
		printf("Inserindo: %d || AVL : %d elementos\n", resp,i);
		printf("%d: ", i+1);
		i++;
		imprime(a);
		printf("\n\nNum: ");
		scanf("%d", &resp);
	}
	
	printf("Deleta NO: ");
	scanf("%d", &resp);
	while(resp != 0){
		a = excluiElemento(resp,a);
		printf("Excluindo: %d\n", resp);
		//printf("%d: ", i+1);
		i++;
		//imprime(a);
		imprimePre(a);
		printf("\n\nNum: ");
		scanf("%d", &resp);
	}
		
	return 0;
}
